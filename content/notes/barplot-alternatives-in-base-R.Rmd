---
title: Easy alternatives to bar charts in native R graphics
author: Jaime Ashander
date: 2015-04-26
tags: R, statistical graphics, visualization, ggplot2, lattice
output:
    md_document:
        variant: markdown_strict
        dev: 'svg'
    encoding: 'UTF-8'
status: draft
---
```{r knit-opts, echo=FALSE}
## important to let caching work between local render and building w/ pelican
knitr::opts_chunk$set(cache = 1)
```

It's a long tradition in statistical graphics going from Tufte back to
[Tukey](http://en.wikipedia.org/wiki/John_Tukey#Scientific_contributions) and
[Cleveland](http://en.wikipedia.org/wiki/Dot_plot_%28statistics%29#Cleveland_dot_plots)
to advise against using bar charts.  Many folks, [including
me](https://twitter.com/jaimedash/status/591289758191636480), have pejoratively
called the common (in ecology, at least) bar chart + SE a "dynamite plot".
Although Ben Bolker has questioned the universality of this received wisdom
("Dynamite Plots: unmitigated evil?", which I link below), I think in most
cases they're worth avoiding. I'll expand on this below.

Last week, Tracey Weisgerber and colleagues echoed this tradition, making a
[great set of concrete recommendations in a perspective for PLoS Biology](doi.org/10.1371/journal.pbio.1002128).
Importantly, the authors also provided a
[set of Excel templates on CTSpedia](https://www.ctspedia.org/do/view/CTSpedia/TemplateTesting)
(a cool-looking site for sharing resources related to clinical trials) that
implement their recommendations in Excel.

This is great because in Excel, making good graphics like this is _really_
hard.  So people don't do it. Best practices have little appeal if they also
involve lots of arcane work to implement!  Fortunately in
[R](http://www.r-project.org/), the recommended alternatives are built in, and
even easier to use.

Here, I'll provide some minimal code to make plots similar to those Weisgerber
_et al_ recommend, both for independent groups and paired data, using the
built-in graphics of [R](http://www.r-project.org/).


# Independent groups

For conveneince, I'm using the built in `CO2` dataset:
```{r data}
head(CO2)
```

These data come from an experiment on cold tolerance in grasses from different
regions, but the specifics here don't matter. The data were first publisehd in
_Ecology_ in 1990. See `?CO2` in R if you'd like to know more.

Mostly, I'll plot CO2 concentration versus uptake or Type, the plant's source
region.

First, a bad ol' dynamite, er bar plot:

```{r barplot, echo=FALSE, fig.cap='bad bar plot'}
barplot(unlist(lapply(split(CO2, CO2$conc), function(x) mean(x$uptake))), ylab='uptake',
        xlab='concentration')
```

(I'm not including the code for this, because it's what I'm recommending
against. Nor did I add error bars, so it's not really a dynamite plot. R's base
graphics make both producing this plot and, especially, adding error bars to
it, tedious compared to box plots or strip charts. Maybe this is a feature.
External libraries like `ggplot` or `gplots` make such graphics a lot easier.
See link at the end of this post.)

## Scatter plots

The first type of plot is a univariate scatter plot.  Most often, you'd want to
plot a response against some observational or experimental factors. Another
name for this type of plot is `stripchart`, which is what R calls it:

```{r, scatter-v-factors, fig.cap = 'stripchart: a scatter plot v factors'}
CO2 <- within(CO2, conc_f <- factor(conc))
y_limits <- c(0, max(CO2$uptake) * 1.15)
point_col <- gray(0.4)
stripchart(uptake ~ conc_f, CO2, method='jitter', pch=19, col=point_col,
           xlab='concentration', ylim=y_limits, vertical=TRUE)
```

It's easy to jitter the points, as Weisgerber _et al_ recommend, by passing the
argument `method='jitter'`. But there are other options.  For cases where there
really isn't much data, `method='stack'` gives something closer to a
[Wilkinson dot plot](http://en.wikipedia.org/wiki/Dot_plot_%28statistics%29#Wilkinson_dot_plots).
This more clearly shows the values that were observed more than once:


```{r, stripchart-wilkinson, fig.cap = 'stripchart with stacking'}
stripchart(uptake ~ conc_f, CO2, method='stack', pch=19, col=point_col,
           xlab='concentration',  ylim=y_limits, vertical=TRUE)
```

## Box (and whisker) plots

For box plots, R makes it very easy.

```{r, boxplot, fig.cap = 'boxplot'}

boxplot( uptake ~ conc_f , CO2, ylab='uptake', xlab='concentration', ylim=y_limits)
```
In this case, with small data the boxplot is a bit misleading. This is clear from the
scatter plots above, but with a little more work, you can overplot on the
boxes:

```{r, boxplot-overplotted, fig.cap = 'boxplot with points overplotted'}
jitter <- 0.025
boxplot( uptake ~ conc_f , CO2, ylab='uptake', xlab='concentration', ylim=y_limits)
points(as.numeric(CO2$conc_f) + rnorm(nrow(CO2), sd = jitter), CO2$uptake,
       pch=19, col=point_col)
```

Even with base graphics `boxplot`, you can pass functions of multiple
independent variables. This means you can visualize interactions between
treatments in your raw data:

```{r, complex-boxplot, fig.cap = 'complex bar plot'}
boxplot( uptake ~ conc_f : Treatment, CO2, ylab='uptake', ylim=y_limits,
        xlab = "concentration within chilling treatment")
```

I'm not sure how to easily overplot points on a complex boxplot like this one.
(Without using an external library.) If you know -- drop me a note.

_Note_ it would be easier to read the labels here if the plot were horizontal,
for which there's an argument you can pass. The graphics settings on this post
aren't playing well with long labels, so I don't evaluate this here:

```{r, complex-noneval, eval=FALSE}
op <- par(las = 1, mar = c(4, 8, 2, 1)) # all axis labels horizontal
   boxplot( uptake ~ conc_f %in% Treatment, CO2, xlab='uptake', horizontal=TRUE)
par(op)
```


## Paired data

The CO2 data aren't paired. To look at paired scatter plots, I'll use the built
in `sleep` data, which show extra sleep for subjects taking two sleep aids.

```{r, sleep-dat}
head(sleep)
```

The easiest way to make plots that link paired data is to again use
`stripchart` as a base.  Then, to add lines illustraiting the pairs, one can
use `split` and `lines`:

```{r paired-points, fig.cap = 'paired points connected by lines and marked by points'}

invisible(stripchart(extra ~ group, sleep, pch=19, col=point_col,
		     vertical=TRUE, ylab='extra sleep', xlab='drug received'))
## note -- don't enclose this in invisble in your code -- some strangeness
##         with website production compels it here
for(ID in split(sleep, sleep$ID))
  lines(extra ~ group, ID)

```

If you'd rather only have the lines, just suppress plotting of points within
the initial call to `stripchart`:

```{r paired-lines, fig.cap = 'paired locations connected by lines'}
invisible(stripchart(extra ~ group, sleep, pch="", vertical=TRUE,
           	     ylab='extra sleep', xlab='drug received'))
## note -- don't enclose this in invisble in your code -- some strangeness
##         with website production compels it here
for(ID in split(sleep, sleep$ID))
  lines(extra ~ group, ID)
```


# Other plots

R easily produces many other plots, in addition to those Weisgerber _et al_ for
which provide templates.

For example, say you'd like a histograms across subsets.  Here's one for uptake
from the `CO2` data for grass plants receiving chilling or not:

```{r, histo, fig.cap = 'histogram of uptake'}
op <- par(mfrow=c(2, 1))
for(v in levels(CO2$Treatment)) {
  subs <- subset(CO2, Treatment == v)
  hist(subs$uptake, main = v, col = point_col, xlab = 'uptake', xlim = y_limits)
  }
par(op)
```


# References: plotting libraries and examples

* [lattice](http://www.statmethods.net/advgraphs/trellis.html) uses a formula
  interface on top of grid graphics
* [ggplot2](http://ggplot2.org/) implements the grammar of graphics on top of
  grid graphics
* _note_ if you're familiar with one of the above and not the other,
  [see this guide to translating between lattice and qplot](http://docs.ggplot2.org/0.9.3.1/translate_qplot_lattice.html) and
  [this post summarizing an extensive comparison of the two libraries](https://learnr.wordpress.com/2009/08/26/ggplot2-version-of-figures-in-lattice-multivariate-data-visualization-with-r-final-part/)
* Ben Bolker's
  [post on dynamite plots](http://emdbolker.wikidot.com/blog:dynamite), in which he
  produces a variety of plots on the same data using both `ggplot2` and an older library `gplots`

# When and where are dynamite plots appropriate?

In addition to Ben's post linked above, Solomon Messing has some nice reasons
to choose dot plots for estimates +/- SE ([three paragraphs beginning with "Why
do I use dot
plots..."](https://solomonmessing.wordpress.com/2012/03/04/visualization-series-insight-from-cleveland-and-tufte-on-plotting-numeric-data-by-groups/)).
These boil down to:

* bar charts emphasize comparison to zero, which can make comparison of small
  differences difficult
* bars are often used in histograms, which can confuse some audiences
* dot plots use more ink, and cognition, which causes the eye to compare the estimate with the baseline

I agree with Ben that this last feature, the implied reference to a baseline,
means bar charts, can be very useful. But there's a corollary here: only use
this strength when comparison to a baseline is the point. Further, then,
if your graphics are to be honest, they must start at a meaningful
zero. So, avoid bar charts for estimated quantites. Unless, your main
comparison is between estimates with different, or with magnitudes very close
to zero.
